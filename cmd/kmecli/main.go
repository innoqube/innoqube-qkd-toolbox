package main

import (
	"encoding/pem"
	"fmt"
	"innoqube-qkd-toolbox/pkg/kmetools"
	"log"
	"os"

	"github.com/spf13/cobra"
)

type QKDRuntime struct {
	certificate     string
	privateKey      string
	debug           bool
	quiet           bool
	kmeUrl          string
	sae             string
	keyID           string
	x509certSubject string
	x509validity    int    // days
	x509key         string // base64 QKD key
	x509output      string
}

var qkdRuntime QKDRuntime

var QKDRootCLI = &cobra.Command{
	Use:   "kmecli",
	Short: "A tool for interacting with Quantum Key Management Entities (KMEs).",
	Run: func(cmd *cobra.Command, args []string) {
		if len(args) == 0 {
			cmd.Help()
		}
	},
}

var QKDKMEGetKeyCLI = &cobra.Command{
	Use:   "getkey",
	Short: "Retrieve a key from the QKD KME using a SAE partner",
	Run: func(cmd *cobra.Command, args []string) {
		cert, err := os.ReadFile(qkdRuntime.certificate)
		if err != nil {
			fmt.Printf("[!!] Failed to read certificate: %v", err)
			os.Exit(1)
		}
		privateKey, err := os.ReadFile(qkdRuntime.privateKey)
		if err != nil {
			fmt.Printf("[!!] Failed to read private key: %v", err)
			os.Exit(1)
		}
		status, key := kmetools.KMEKeyGet(cert, privateKey, qkdRuntime.kmeUrl, qkdRuntime.keyID, qkdRuntime.sae, qkdRuntime.debug)
		if status {
			if qkdRuntime.debug {
				fmt.Printf("[--] KeyID: %s\n", key[0])
				fmt.Printf("[--] Key: %s\n", key[1])
			} else {
				fmt.Printf("%s:%s\n", key[0], key[1])
			}
		} else {
			fmt.Printf("[!!] Error: %s\n", key[1])
			os.Exit(1)
		}

	},
	PreRunE: func(cmd *cobra.Command, args []string) error {
		if cmd.Flags().NFlag() < 2 {
			return fmt.Errorf("[!!] getkey: missing some required flags")
		}
		if _, err := os.Stat(qkdRuntime.certificate); err != nil {
			return fmt.Errorf("[!!] Invalid certificate path [%s]", qkdRuntime.certificate)
		}
		if _, err := os.Stat(qkdRuntime.privateKey); err != nil {
			return fmt.Errorf("[!!] Invalid private key path [%s]", qkdRuntime.privateKey)
		}
		return nil
	},
}

var QKDToolX509CLI = &cobra.Command{
	Use:   "x509",
	Short: "Generate X.509 certificate using as seed a QKD key",
	Run: func(cmd *cobra.Command, args []string) {
		privKeyBytes, certBytes := kmetools.KMEx509Generator(qkdRuntime.x509certSubject, qkdRuntime.x509validity, qkdRuntime.x509key)
		if qkdRuntime.x509output == "" {
			pem.Encode(os.Stdout, &pem.Block{
				Type:  "PRIVATE KEY",
				Bytes: privKeyBytes,
			})
			pem.Encode(os.Stdout, &pem.Block{
				Type:  "CERTIFICATE",
				Bytes: certBytes,
			})
		} else {
			privKeyFile, err := os.Create(qkdRuntime.x509output + "-privatekey.pem")
			if err != nil {
				log.Fatalf("Failed to open %s-privatekey.pem: %v\n", qkdRuntime.x509output, err)
			}
			defer privKeyFile.Close()

			pem.Encode(privKeyFile, &pem.Block{
				Type:  "PRIVATE KEY",
				Bytes: privKeyBytes,
			})
			log.Printf("Private key saved to %s-privatekey.pem", qkdRuntime.x509output)
			certFile, err := os.Create(qkdRuntime.x509output + "-certificate.pem")
			if err != nil {
				log.Fatalf("Failed to open %s-certificate.pem: %v\n", qkdRuntime.x509output, err)
			}
			defer certFile.Close()

			pem.Encode(certFile, &pem.Block{
				Type:  "CERTIFICATE",
				Bytes: certBytes,
			})
			log.Printf("Certificate saved to %s-certificate.pem", qkdRuntime.x509output)
		}
	},
	PreRunE: func(cmd *cobra.Command, args []string) error {
		if cmd.Flags().NFlag() < 2 {
			return fmt.Errorf("[!!] x509: missing some required flags")
		}
		return nil
	},
}

func init() {

}

func main() {
	QKDRootCLI.PersistentFlags().BoolVar(&qkdRuntime.debug, "debug", false, "Enable debug mode (default: false)")
	QKDRootCLI.PersistentFlags().BoolVar(&qkdRuntime.quiet, "quiet", false, "Enable quiet mode (default: false)")

	QKDKMEGetKeyCLI.Flags().StringVar(&qkdRuntime.certificate, "certificate", os.Getenv("QKD_CLIENT_CERTIFICATE"), "Path to the QKD client certificate")
	QKDKMEGetKeyCLI.Flags().StringVar(&qkdRuntime.privateKey, "privatekey", os.Getenv("QKD_CLIENT_PRIVATE_KEY"), "Path to the QKD client private key")
	QKDKMEGetKeyCLI.Flags().StringVar(&qkdRuntime.sae, "qkd-sae", os.Getenv("QKD_SAE"), "Name of the target SAE")
	QKDKMEGetKeyCLI.Flags().StringVar(&qkdRuntime.kmeUrl, "qkd-kme-url", os.Getenv("QKD_KME_URL"), "URL for the QKD KME endpoint")
	QKDKMEGetKeyCLI.Flags().StringVar(&qkdRuntime.keyID, "qkd-keyid", os.Getenv("QKD_KEYID"), "(optional) ID for the QKD key generated by KME")
	QKDKMEGetKeyCLI.MarkFlagRequired("certificate")
	QKDKMEGetKeyCLI.MarkFlagRequired("privatekey")
	QKDKMEGetKeyCLI.MarkFlagRequired("qkd-sae")
	QKDKMEGetKeyCLI.MarkFlagRequired("qkd-kme-url")

	QKDToolX509CLI.Flags().StringVar(&qkdRuntime.x509certSubject, "subject", "", "Subject (dn) for the X.509 certificate (example: /C=RO/ST=TM/L=Timisoara/OU=Quantum Division/O=InnoQube/CN=quantum-app-1)")
	QKDToolX509CLI.Flags().IntVar(&qkdRuntime.x509validity, "validity", 365, "Validity period (days) for the X.509 certificate")
	QKDToolX509CLI.Flags().StringVar(&qkdRuntime.x509key, "key", "", "Base64 encoded QKD key")
	QKDToolX509CLI.Flags().StringVar(&qkdRuntime.x509output, "output", "", "Output prefix to be used in filenames for the generated certificate (if empty the certificate and private key will be printed to stdout)")
	QKDToolX509CLI.MarkFlagRequired("subject")
	QKDToolX509CLI.MarkFlagRequired("key")

	QKDRootCLI.AddCommand(QKDKMEGetKeyCLI)
	QKDRootCLI.AddCommand(QKDToolX509CLI)

	if err := QKDRootCLI.Execute(); err != nil {
		os.Exit(1)
	}
}
