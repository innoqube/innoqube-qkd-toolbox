package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"
)

type QKDRuntime struct {
	certificate string
	privateKey  string
	kme         string
	sae         string
	keyID       string
}

// QKD KME response JSON parser
type KeysResponse struct {
	Keys []Key `json:"keys"`
}
type Key struct {
	KeyID string `json:"key_ID"`
	Key   string `json:"key"`
}

const qkd_api_keys_dec_url string = "/api/v1/keys/%s/dec_keys"

var _cert = flag.String("certificate", os.Getenv("QKD_CLIENT_CERTIFICATE"), "Patch to the QKD client certificate")
var _key = flag.String("privatekey", os.Getenv("QKD_CLIENT_PRIVATE_KEY"), "Path to the QKD client private key")

var _qkd_sae = flag.String("qkd-sae", os.Getenv("QKD_SAE"), "Name of the target SAE")
var _qkd_kme = flag.String("qkd-kme", os.Getenv("QKD_KME"), "URL for the QKD KME endpoint")
var _qkd_keyid = flag.String("qkd-keyid", os.Getenv("QKD_KEYID"), "ID for the QKD key generated by KME")

var _debug = flag.Bool("debug", false, "Enable debug mode")

var qkdRuntime QKDRuntime

func _args_validator() int {
	flag.Parse()
	if *_cert == "" || *_key == "" {
		log.Fatalf("[!!] Both certificate and private key must be provided.")
		flag.Usage()
		return -1
	} else {
		_, err := os.Stat(*_cert)
		if err != nil {
			log.Fatalf("[!!] Invalid certificate path [%s]\n", *_cert)
			return -1
		}
		_, err = os.Stat(*_key)
		if err != nil {
			log.Fatalf("[!!] Invalid private key path [%s]\n", *_key)
			return -1
		}
	}

	if *_qkd_sae == "" {
		log.Fatalf("[!!] QKD SAE short name must be provided.")
		flag.Usage()
		return -1
	}

	if *_qkd_kme == "" {
		log.Fatalf("[!!] QKD KME endpoint must be provided.")
		flag.Usage()
		return -1
	}

	if *_qkd_keyid == "" {
		log.Fatalf("[!!] QKD Key ID must be provided.")
		flag.Usage()
		return -1
	}
	qkdRuntime = QKDRuntime{
		certificate: *_cert,
		privateKey:  *_key,
		kme:         *_qkd_kme,
		sae:         *_qkd_sae,
		keyID:       *_qkd_keyid,
	}
	return 0
}

func _qkd_api_generator() string {
	_dec_url := fmt.Sprintf(qkd_api_keys_dec_url, qkdRuntime.sae)
	_kme_url := fmt.Sprintf("%s%s", strings.TrimSuffix(*_qkd_kme, "/"), _dec_url)
	log.Printf("[--] QKD API URL: %s\n", *_qkd_kme)
	log.Printf("[--] QKD SAE: %s\n", *_qkd_sae)
	log.Printf("[--] QKD KeyID: %s\n", *_qkd_keyid)
	log.Printf("[--] TLS options:\n\t- Certificate: %s\n\t- Private Key: %s\n", qkdRuntime.certificate, qkdRuntime.privateKey)
	return _kme_url
}

func _qkd_api_call(kme_url string, keyid string) string {
	tr := &http.Transport{
		DisableCompression: true,
	}
	log.Printf("[--] Calling KME URL: %s\n", kme_url)

	_req_data := map[string][]map[string]string{
		"key_IDs": {
			{"key_ID": keyid},
		},
	}
	jd, err := json.Marshal(_req_data)
	if err != nil {
		log.Fatalf("[!!] Error marshaling JSON: %s", err)
	}
	if *_debug {
		log.Printf("[dd] Request Data: %s\n", jd)
	}

	client := &http.Client{
		Timeout:   4 * time.Second,
		Transport: tr,
	}
	req, err := http.NewRequest("POST", kme_url, bytes.NewBuffer(jd))
	if err != nil {
		log.Fatalf("[!!] Error creating request: %s", err)
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("[!!] Error making request: %s", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("[!!] Error reading response body: %s", err)
	}

	if *_debug {
		log.Printf("[dd] Response Status: %s\n", resp.Status)
		log.Printf("[dd] Response Body: %s\n", body)
	}

	var response KeysResponse
	err = json.Unmarshal(body, &response)
	if err != nil {
		log.Fatalf("[!!] Error unmarshaling JSON: %s", err)
	}

	if response.Keys[0].KeyID != qkdRuntime.keyID {
		log.Fatalf("[!!] KME returned keyID not matching the provided keyID. [Expected: %s, Got: %s]", qkdRuntime.keyID, response.Keys[0].KeyID)
	}

	return response.Keys[0].Key
}

func main() {
	var _code int = _args_validator()
	if _code != 0 {
		os.Exit(_code)
	}
	qkd_api_url := _qkd_api_generator()
	qkd_key := _qkd_api_call(qkd_api_url, qkdRuntime.keyID)
	log.Printf("[--] Key retrieved successfully: %s\n", qkd_key)
}
